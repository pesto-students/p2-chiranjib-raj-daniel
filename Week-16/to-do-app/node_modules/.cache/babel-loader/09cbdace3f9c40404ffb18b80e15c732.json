{"ast":null,"code":"import { timestampWithMs, logger } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\nvar DEFAULT_IDLE_TIMEOUT = 1000;\nvar DEFAULT_FINAL_TIMEOUT = 30000;\nvar HEARTBEAT_INTERVAL = 5000;\n/**\n * @inheritDoc\n */\n\nclass IdleTransactionSpanRecorder extends SpanRecorder {\n  constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    super(maxlen);\n    this._pushActivity = _pushActivity;\n    this._popActivity = _popActivity;\n    this.transactionSpanId = transactionSpanId;\n    ;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  add(span) {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = endTimestamp => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n\n        this._popActivity(span.spanId);\n      }; // We should only push new activities if the span does not have an end timestamp.\n\n\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n\n}\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\n\n\nclass IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  __init() {\n    this.activities = {};\n  } // Track state of activities in previous heartbeat\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n\n\n  __init2() {\n    this._heartbeatCounter = 0;\n  } // We should not use heartbeat if we finished a transaction\n\n\n  __init3() {\n    this._finished = false;\n  }\n\n  __init4() {\n    this._beforeFinishCallbacks = [];\n  }\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n\n\n  constructor(transactionContext, _idleHub) {\n    let _idleTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_IDLE_TIMEOUT;\n\n    let _finalTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_FINAL_TIMEOUT;\n\n    let _onScope = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    super(transactionContext, _idleHub);\n    this._idleHub = _idleHub;\n    this._idleTimeout = _idleTimeout;\n    this._finalTimeout = _finalTimeout;\n    this._onScope = _onScope;\n\n    IdleTransaction.prototype.__init.call(this);\n\n    IdleTransaction.prototype.__init2.call(this);\n\n    IdleTransaction.prototype.__init3.call(this);\n\n    IdleTransaction.prototype.__init4.call(this);\n\n    ;\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub); // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._startIdleTimeout();\n\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n  /** {@inheritDoc} */\n\n\n  finish() {\n    let endTimestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timestampWithMs();\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (var callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter(span => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        } // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n\n\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        var keepSpan = span.startTimestamp < endTimestamp;\n\n        if (!keepSpan) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n        }\n\n        return keepSpan;\n      });\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n    } // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n\n\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n\n\n  registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  initSpanRecorder(maxlen) {\n    if (!this.spanRecorder) {\n      var pushActivity = id => {\n        if (this._finished) {\n          return;\n        }\n\n        this._pushActivity(id);\n      };\n\n      var popActivity = id => {\n        if (this._finished) {\n          return;\n        }\n\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen); // Start heartbeat so that transactions do not run forever.\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n\n      this._pingHeartbeat();\n    }\n\n    this.spanRecorder.add(this);\n  }\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n\n\n  _cancelIdleTimeout() {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n  /**\n   * Creates an idletimeout\n   */\n\n\n  _startIdleTimeout(endTimestamp) {\n    this._cancelIdleTimeout();\n\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n\n\n  _pushActivity(spanId) {\n    this._cancelIdleTimeout();\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n\n\n  _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] popActivity ${spanId}`);\n      delete this.activities[spanId];\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      var endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n\n\n  _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    var heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n  /**\n   * Pings the heartbeat\n   */\n\n\n  _pingHeartbeat() {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, HEARTBEAT_INTERVAL);\n  }\n\n}\n/**\n * Reset transaction on scope to `undefined`\n */\n\n\nfunction clearActiveTransaction(hub) {\n  var scope = hub.getScope();\n\n  if (scope) {\n    var transaction = scope.getTransaction();\n\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\n\nexport { DEFAULT_FINAL_TIMEOUT, DEFAULT_IDLE_TIMEOUT, HEARTBEAT_INTERVAL, IdleTransaction, IdleTransactionSpanRecorder };","map":{"version":3,"mappings":";;;;;;AAYA;AACA;AACA;;;EAEAA,YACAC,aADA,EAEAC,YAFA,EAGAC,iBAHA,EAIAC,MAJA,EAKA;IACA;IAAA;IAAA;IAAA;IAAA;EACA;EAEA;AACA;AACA;;;EACAC;IACA;IACA;IACA;MACA;MACAC;QACAA;;QACA;MACA,CAHA,CAFA,CAOA;;;MACA;QACA;MACA;IACA;;IAEA;EACA;;;AAKA;AACA;AACA;AACA;AACA;;;;EAEA;EACAC;IAAA;EAAA,EAEA;EAGA;;;EACAC;IAAA;EAAA,EAEA;;;EACAC;IAAA;EAAA;;EAEAC;IAAA;EAAA;EAEA;AACA;AACA;;;EAGAV,YACAW,kBADA,EAEAC,QAFA,EAcA;IAAA,IAPAC,YAOA,uEAPAC,oBAOA;;IAAA,IAHAC,aAGA,uEAHAC,qBAGA;;IAAA,IADAC,QACA,uEADA,KACA;;IACA;IAAA;IAAA;IAAA;IAAA;;IAAAC;;IAAAA;;IAAAA;;IAAAA;;IAAA;;IAEA;MACA;MACAC,iCAFA,CAIA;MACA;;MACA;;MACAP;IACA;;IAEA;;IACAQ;MACA;QACA;QACA;MACA;IACA,CALA,EAKA,kBALA;EAMA;EAEA;;;EACAC;IAAA;IACA;IACA;;IAEA;MACA,iEACAC,uGADA;;MAGA;QACAC;MACA;;MAEA;QACA;QACA;UACA;QACA,CAJA,CAMA;;;QACA;UACAjB;UACAA;UACA,iEACAgB,yGADA;QAEA;;QAEA;;QACA;UACA,iEACAA,WACA,4EADA,EAEAE,kCAFA,CADA;QAKA;;QACA;MACA,CAvBA;MAyBA;IACA,CAlCA,MAkCA;MACA;IACA,CAxCA,CA0CA;;;IACA;MACAL;IACA;;IAEA;EACA;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACAM;IACA;EACA;EAEA;AACA;AACA;;;EACAC;IACA;MACA;QACA;UACA;QACA;;QACA;MACA,CALA;;MAMA;QACA;UACA;QACA;;QACA;MACA,CALA;;MAOA,oGAdA,CAgBA;;MACA;;MACA;IACA;;IACA;EACA;EAEA;AACA;AACA;;;EACAC;IACA;MACAC;MACA;IACA;EACA;EAEA;AACA;AACA;;;EACAC;IACA;;IACA;MACA;QACA;MACA;IACA,CAJA,EAIA,iBAJA;EAKA;EAEA;AACA;AACA;AACA;;;EACA5B;IACA;;IACA;IACA;IACA;EACA;EAEA;AACA;AACA;AACA;;;EACAC;IACA;MACA;MACA;MAEA;IACA;;IAEA;MACA;MACA;MACA;;MACA;IACA;EACA;EAEA;AACA;AACA;AACA;;;EACA4B;IACA;IACA;MACA;IACA;;IAEA;;IAEA;MACA;IACA,CAFA,MAEA;MACA;IACA;;IAEA;;IAEA;MACA;MACA;MACA;IACA,CAJA,MAIA;MACA;IACA;EACA;EAEA;AACA;AACA;;;EACAC;IACA;IACAX;MACA;IACA,CAFA,EAEAY,kBAFA;EAGA;;;AAGA;AACA;AACA;;;AACA;EACA;;EACA;IACA;;IACA;MACAC;IACA;EACA;AACA","names":["constructor","_pushActivity","_popActivity","transactionSpanId","maxlen","add","span","__init","__init2","__init3","__init4","transactionContext","_idleHub","_idleTimeout","DEFAULT_IDLE_TIMEOUT","_finalTimeout","DEFAULT_FINAL_TIMEOUT","_onScope","IdleTransaction","clearActiveTransaction","setTimeout","finish","logger","callback","JSON","registerBeforeFinishCallback","initSpanRecorder","_cancelIdleTimeout","clearTimeout","_startIdleTimeout","_beat","_pingHeartbeat","HEARTBEAT_INTERVAL","scope"],"sources":["/Users/danielraj/Desktop/p2-chiranjib-raj-daniel/Week-16/to-do-app/node_modules/src/idletransaction.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { Hub } from '@sentry/hub';\nimport { TransactionContext } from '@sentry/types';\nimport { logger, timestampWithMs } from '@sentry/utils';\n\nimport { Span, SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const DEFAULT_IDLE_TIMEOUT = 1000;\nexport const DEFAULT_FINAL_TIMEOUT = 30000;\nexport const HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string,\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n  private _idleTimeoutID: ReturnType<typeof setTimeout> | undefined;\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n    private readonly _idleTimeout: number = DEFAULT_IDLE_TIMEOUT,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n    private readonly _finalTimeout: number = DEFAULT_FINAL_TIMEOUT,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      __DEBUG_BUILD__ && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._startIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampWithMs()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      __DEBUG_BUILD__ &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          __DEBUG_BUILD__ &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          __DEBUG_BUILD__ &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      __DEBUG_BUILD__ && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      __DEBUG_BUILD__ && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      __DEBUG_BUILD__ && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n  private _cancelIdleTimeout(): void {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Creates an idletimeout\n   */\n  private _startIdleTimeout(endTimestamp?: Parameters<IdleTransaction['finish']>[0]): void {\n    this._cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    this._cancelIdleTimeout();\n    __DEBUG_BUILD__ && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      __DEBUG_BUILD__ && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      __DEBUG_BUILD__ && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      __DEBUG_BUILD__ && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    __DEBUG_BUILD__ && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, HEARTBEAT_INTERVAL);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub: Hub): void {\n  const scope = hub.getScope();\n  if (scope) {\n    const transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}