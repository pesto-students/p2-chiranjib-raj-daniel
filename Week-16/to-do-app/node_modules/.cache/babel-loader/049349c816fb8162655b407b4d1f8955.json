{"ast":null,"code":"import { isString } from './is.js';\nimport { logger } from './logger.js';\nvar BAGGAGE_HEADER_NAME = 'baggage';\nvar SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\nvar SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\n\nvar MAX_BAGGAGE_STRING_LENGTH = 8192;\n/** Create an instance of Baggage */\n\nfunction createBaggage(initItems) {\n  let baggageString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let mutable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return [{ ...initItems\n  }, baggageString, mutable];\n}\n/** Get a value from baggage */\n\n\nfunction getBaggageValue(baggage, key) {\n  return baggage[0][key];\n}\n/** Add a value to baggage */\n\n\nfunction setBaggageValue(baggage, key, value) {\n  if (isBaggageMutable(baggage)) {\n    baggage[0][key] = value;\n  }\n}\n/** Check if the Sentry part of the passed baggage (i.e. the first element in the tuple) is empty */\n\n\nfunction isSentryBaggageEmpty(baggage) {\n  return Object.keys(baggage[0]).length === 0;\n}\n/** Returns Sentry specific baggage values */\n\n\nfunction getSentryBaggageItems(baggage) {\n  return baggage[0];\n}\n/**\n * Returns 3rd party baggage string of @param baggage\n * @param baggage\n */\n\n\nfunction getThirdPartyBaggage(baggage) {\n  return baggage[1];\n}\n/**\n * Checks if baggage is mutable\n * @param baggage\n * @returns true if baggage is mutable, else false\n */\n\n\nfunction isBaggageMutable(baggage) {\n  return baggage[2];\n}\n/**\n * Sets the passed baggage immutable\n * @param baggage\n */\n\n\nfunction setBaggageImmutable(baggage) {\n  baggage[2] = false;\n}\n/** Serialize a baggage object */\n\n\nfunction serializeBaggage(baggage) {\n  return Object.keys(baggage[0]).reduce((prev, key) => {\n    var val = baggage[0][key];\n    var baggageEntry = `${SENTRY_BAGGAGE_KEY_PREFIX}${encodeURIComponent(key)}=${encodeURIComponent(val)}`;\n    var newVal = prev === '' ? baggageEntry : `${prev},${baggageEntry}`;\n\n    if (newVal.length > MAX_BAGGAGE_STRING_LENGTH) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Not adding key: ${key} with val: ${val} to baggage due to exceeding baggage size limits.`);\n      return prev;\n    } else {\n      return newVal;\n    }\n  }, baggage[1]);\n}\n/**\n * Parse a baggage header from a string or a string array and return a Baggage object\n *\n * If @param includeThirdPartyEntries is set to true, third party baggage entries are added to the Baggage object\n * (This is necessary for merging potentially pre-existing baggage headers in outgoing requests with\n * our `sentry-` values)\n */\n\n\nfunction parseBaggageHeader(inputBaggageValue) {\n  let includeThirdPartyEntries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // Adding this check here because we got reports of this function failing due to the input value\n  // not being a string. This debug log might help us determine what's going on here.\n  if (!Array.isArray(inputBaggageValue) && !isString(inputBaggageValue) || typeof inputBaggageValue === 'number') {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('[parseBaggageHeader] Received input value of incompatible type: ', typeof inputBaggageValue, inputBaggageValue); // Gonna early-return an empty baggage object so that we don't fail later on\n\n    return createBaggage({}, '');\n  }\n\n  var baggageEntries = (isString(inputBaggageValue) ? inputBaggageValue : inputBaggageValue.join(',')).split(',').map(entry => entry.trim()).filter(entry => entry !== '' && (includeThirdPartyEntries || SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(entry)));\n  return baggageEntries.reduce((_ref, curr) => {\n    let [baggageObj, baggageString] = _ref;\n    const [key, val] = curr.split('=');\n\n    if (SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(key)) {\n      var baggageKey = decodeURIComponent(key.split('-')[1]);\n      return [{ ...baggageObj,\n        [baggageKey]: decodeURIComponent(val)\n      }, baggageString, true];\n    } else {\n      return [baggageObj, baggageString === '' ? curr : `${baggageString},${curr}`, true];\n    }\n  }, [{}, '', true]);\n}\n/**\n * Merges the baggage header we saved from the incoming request (or meta tag) with\n * a possibly created or modified baggage header by a third party that's been added\n * to the outgoing request header.\n *\n * In case @param headerBaggageString exists, we can safely add the the 3rd party part of @param headerBaggage\n * with our @param incomingBaggage. This is possible because if we modified anything beforehand,\n * it would only affect parts of the sentry baggage (@see Baggage interface).\n *\n * @param incomingBaggage the baggage header of the incoming request that might contain sentry entries\n * @param thirdPartyBaggageHeader possibly existing baggage header string or string[] added from a third\n *        party to the request headers\n *\n * @return a merged and serialized baggage string to be propagated with the outgoing request\n */\n\n\nfunction mergeAndSerializeBaggage(incomingBaggage, thirdPartyBaggageHeader) {\n  if (!incomingBaggage && !thirdPartyBaggageHeader) {\n    return '';\n  }\n\n  var headerBaggage = thirdPartyBaggageHeader && parseBaggageHeader(thirdPartyBaggageHeader, true) || undefined;\n  var thirdPartyHeaderBaggage = headerBaggage && getThirdPartyBaggage(headerBaggage);\n  var finalBaggage = createBaggage(incomingBaggage && incomingBaggage[0] || {}, thirdPartyHeaderBaggage || '');\n  return serializeBaggage(finalBaggage);\n}\n/**\n * Helper function that takes a raw baggage value (if available) and the processed sentry-trace header\n * data (if available), parses the baggage value and creates a Baggage object. If there is no baggage\n * value, it will create an empty Baggage object.\n *\n * In a second step, this functions determines if the created Baggage object should be set immutable\n * to prevent mutation of the Sentry data. It does this by looking at the processed sentry-trace header.\n *\n * @param rawBaggageValue baggage value from header\n * @param sentryTraceHeader processed Sentry trace header returned from `extractTraceparentData`\n */\n\n\nfunction parseBaggageSetMutability(rawBaggageValue, sentryTraceHeader) {\n  var baggage = parseBaggageHeader(rawBaggageValue || ''); // Because we are always creating a Baggage object by calling `parseBaggageHeader` above\n  // (either a filled one or an empty one, even if we didn't get a `baggage` header),\n  // we only need to check if we have a sentry-trace header or not. As soon as we have it,\n  // we set baggage immutable. In case we don't get a sentry-trace header, we can assume that\n  // this SDK is the head of the trace and thus we still permit mutation at this time.\n  // There is one exception though, which is that we get a baggage-header with `sentry-`\n  // items but NO sentry-trace header. In this case we also set the baggage immutable for now\n  // but if something like this would ever happen, we should revisit this and determine\n  // what this would actually mean for the trace (i.e. is this SDK the head?, what happened\n  // before that we don't have a sentry-trace header?, etc)\n\n  (sentryTraceHeader || !isSentryBaggageEmpty(baggage)) && setBaggageImmutable(baggage);\n  return baggage;\n}\n\nexport { BAGGAGE_HEADER_NAME, MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, createBaggage, getBaggageValue, getSentryBaggageItems, getThirdPartyBaggage, isBaggageMutable, isSentryBaggageEmpty, mergeAndSerializeBaggage, parseBaggageHeader, parseBaggageSetMutability, serializeBaggage, setBaggageImmutable, setBaggageValue };","map":{"version":3,"mappings":";;;;;AAWA;AACA;AACA;AACA;AACA;;;AAGA;;;;;EAEA;EAAA;AACA;AAEA;;;;EAEA;AACA;AAEA;;;;EAEA;IACAA;EACA;AACA;AAEA;;;;EAEA;AACA;AAEA;;;;EAEA;AACA;AAEA;AACA;AACA;AACA;;;;EAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;EAEA;AACA;AAEA;AACA;AACA;AACA;;;;EAEAA;AACA;AAEA;;;;EAEA;IACA;IACA;IACA;;IACA;MACA,iEACAC,uGADA;MAEA;IACA,CAJA,MAIA;MACA;IACA;EACA,CAXA,EAWAD,UAXA;AAYA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;4BAEAE,mBAEA;EAAA,IADAC,wBACA,uEADA,KACA;;EACA;EACA;EACA;IACA,iEACAF,YACA,kEADA,EAEA,wBAFA,EAGAC,iBAHA,CADA,CADA,CAQA;;IACA;EACA;;EAEA,qGACAE,KADA,CACA,GADA,EAEAC,GAFA,CAEAC,qBAFA,EAGAC,MAHA,CAGAD,kGAHA;EAKA,6BACA;IAAA;IACA;;IACA;MACA;MACA,QACA,EACA,aADA;QAEA;MAFA,CADA,EAKAE,aALA,EAMA,IANA;IAQA,CAVA,MAUA;MACA;IACA;EACA,CAhBA,EAiBA,cAjBA;AAmBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;EAEA;IACA;EACA;;EAEA;EACA;EAEA;EACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;mCAEAC,iBACAC,mBACA;EACA,wDADA,CAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EAEA;AACA","names":["baggage","logger","inputBaggageValue","includeThirdPartyEntries","split","map","entry","filter","baggageString","rawBaggageValue","sentryTraceHeader"],"sources":["/Users/danielraj/Desktop/p2-chiranjib-raj-daniel/Week-16/to-do-app/node_modules/@sentry/src/baggage.ts"],"sourcesContent":["import { Baggage, BaggageObj, HttpHeaderValue, TraceparentData } from '@sentry/types';\n\nimport { isString } from './is';\nimport { logger } from './logger';\n\nexport const BAGGAGE_HEADER_NAME = 'baggage';\n\nexport const SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nexport const SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nexport const MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/** Create an instance of Baggage */\nexport function createBaggage(initItems: BaggageObj, baggageString: string = '', mutable: boolean = true): Baggage {\n  return [{ ...initItems }, baggageString, mutable];\n}\n\n/** Get a value from baggage */\nexport function getBaggageValue(baggage: Baggage, key: keyof BaggageObj): BaggageObj[keyof BaggageObj] {\n  return baggage[0][key];\n}\n\n/** Add a value to baggage */\nexport function setBaggageValue(baggage: Baggage, key: keyof BaggageObj, value: BaggageObj[keyof BaggageObj]): void {\n  if (isBaggageMutable(baggage)) {\n    baggage[0][key] = value;\n  }\n}\n\n/** Check if the Sentry part of the passed baggage (i.e. the first element in the tuple) is empty */\nexport function isSentryBaggageEmpty(baggage: Baggage): boolean {\n  return Object.keys(baggage[0]).length === 0;\n}\n\n/** Returns Sentry specific baggage values */\nexport function getSentryBaggageItems(baggage: Baggage): BaggageObj {\n  return baggage[0];\n}\n\n/**\n * Returns 3rd party baggage string of @param baggage\n * @param baggage\n */\nexport function getThirdPartyBaggage(baggage: Baggage): string {\n  return baggage[1];\n}\n\n/**\n * Checks if baggage is mutable\n * @param baggage\n * @returns true if baggage is mutable, else false\n */\nexport function isBaggageMutable(baggage: Baggage): boolean {\n  return baggage[2];\n}\n\n/**\n * Sets the passed baggage immutable\n * @param baggage\n */\nexport function setBaggageImmutable(baggage: Baggage): void {\n  baggage[2] = false;\n}\n\n/** Serialize a baggage object */\nexport function serializeBaggage(baggage: Baggage): string {\n  return Object.keys(baggage[0]).reduce((prev, key: keyof BaggageObj) => {\n    const val = baggage[0][key] as string;\n    const baggageEntry = `${SENTRY_BAGGAGE_KEY_PREFIX}${encodeURIComponent(key)}=${encodeURIComponent(val)}`;\n    const newVal = prev === '' ? baggageEntry : `${prev},${baggageEntry}`;\n    if (newVal.length > MAX_BAGGAGE_STRING_LENGTH) {\n      __DEBUG_BUILD__ &&\n        logger.warn(`Not adding key: ${key} with val: ${val} to baggage due to exceeding baggage size limits.`);\n      return prev;\n    } else {\n      return newVal;\n    }\n  }, baggage[1]);\n}\n\n/**\n * Parse a baggage header from a string or a string array and return a Baggage object\n *\n * If @param includeThirdPartyEntries is set to true, third party baggage entries are added to the Baggage object\n * (This is necessary for merging potentially pre-existing baggage headers in outgoing requests with\n * our `sentry-` values)\n */\nexport function parseBaggageHeader(\n  inputBaggageValue: HttpHeaderValue,\n  includeThirdPartyEntries: boolean = false,\n): Baggage {\n  // Adding this check here because we got reports of this function failing due to the input value\n  // not being a string. This debug log might help us determine what's going on here.\n  if ((!Array.isArray(inputBaggageValue) && !isString(inputBaggageValue)) || typeof inputBaggageValue === 'number') {\n    __DEBUG_BUILD__ &&\n      logger.warn(\n        '[parseBaggageHeader] Received input value of incompatible type: ',\n        typeof inputBaggageValue,\n        inputBaggageValue,\n      );\n\n    // Gonna early-return an empty baggage object so that we don't fail later on\n    return createBaggage({}, '');\n  }\n\n  const baggageEntries = (isString(inputBaggageValue) ? inputBaggageValue : inputBaggageValue.join(','))\n    .split(',')\n    .map(entry => entry.trim())\n    .filter(entry => entry !== '' && (includeThirdPartyEntries || SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(entry)));\n\n  return baggageEntries.reduce(\n    ([baggageObj, baggageString], curr) => {\n      const [key, val] = curr.split('=');\n      if (SENTRY_BAGGAGE_KEY_PREFIX_REGEX.test(key)) {\n        const baggageKey = decodeURIComponent(key.split('-')[1]);\n        return [\n          {\n            ...baggageObj,\n            [baggageKey]: decodeURIComponent(val),\n          },\n          baggageString,\n          true,\n        ];\n      } else {\n        return [baggageObj, baggageString === '' ? curr : `${baggageString},${curr}`, true];\n      }\n    },\n    [{}, '', true],\n  );\n}\n\n/**\n * Merges the baggage header we saved from the incoming request (or meta tag) with\n * a possibly created or modified baggage header by a third party that's been added\n * to the outgoing request header.\n *\n * In case @param headerBaggageString exists, we can safely add the the 3rd party part of @param headerBaggage\n * with our @param incomingBaggage. This is possible because if we modified anything beforehand,\n * it would only affect parts of the sentry baggage (@see Baggage interface).\n *\n * @param incomingBaggage the baggage header of the incoming request that might contain sentry entries\n * @param thirdPartyBaggageHeader possibly existing baggage header string or string[] added from a third\n *        party to the request headers\n *\n * @return a merged and serialized baggage string to be propagated with the outgoing request\n */\nexport function mergeAndSerializeBaggage(incomingBaggage?: Baggage, thirdPartyBaggageHeader?: HttpHeaderValue): string {\n  if (!incomingBaggage && !thirdPartyBaggageHeader) {\n    return '';\n  }\n\n  const headerBaggage = (thirdPartyBaggageHeader && parseBaggageHeader(thirdPartyBaggageHeader, true)) || undefined;\n  const thirdPartyHeaderBaggage = headerBaggage && getThirdPartyBaggage(headerBaggage);\n\n  const finalBaggage = createBaggage((incomingBaggage && incomingBaggage[0]) || {}, thirdPartyHeaderBaggage || '');\n  return serializeBaggage(finalBaggage);\n}\n\n/**\n * Helper function that takes a raw baggage value (if available) and the processed sentry-trace header\n * data (if available), parses the baggage value and creates a Baggage object. If there is no baggage\n * value, it will create an empty Baggage object.\n *\n * In a second step, this functions determines if the created Baggage object should be set immutable\n * to prevent mutation of the Sentry data. It does this by looking at the processed sentry-trace header.\n *\n * @param rawBaggageValue baggage value from header\n * @param sentryTraceHeader processed Sentry trace header returned from `extractTraceparentData`\n */\nexport function parseBaggageSetMutability(\n  rawBaggageValue: HttpHeaderValue | false | undefined,\n  sentryTraceHeader: TraceparentData | string | false | undefined | null,\n): Baggage {\n  const baggage = parseBaggageHeader(rawBaggageValue || '');\n\n  // Because we are always creating a Baggage object by calling `parseBaggageHeader` above\n  // (either a filled one or an empty one, even if we didn't get a `baggage` header),\n  // we only need to check if we have a sentry-trace header or not. As soon as we have it,\n  // we set baggage immutable. In case we don't get a sentry-trace header, we can assume that\n  // this SDK is the head of the trace and thus we still permit mutation at this time.\n  // There is one exception though, which is that we get a baggage-header with `sentry-`\n  // items but NO sentry-trace header. In this case we also set the baggage immutable for now\n  // but if something like this would ever happen, we should revisit this and determine\n  // what this would actually mean for the trace (i.e. is this SDK the head?, what happened\n  // before that we don't have a sentry-trace header?, etc)\n  (sentryTraceHeader || !isSentryBaggageEmpty(baggage)) && setBaggageImmutable(baggage);\n\n  return baggage;\n}\n"]},"metadata":{},"sourceType":"module"}